#!/usr/bin/python
from read_xcode import *
def makePathAbsolute(p): #searches the global sourceTreeAlias dictionary and replaces a path prefix that matches a source tree name
	global sourceTreeAlias
	for k, v in sourceTreeAlias.iteritems():
		if p.startswith(k):
			return v + p[len(k):]
		if p.startswith(k[1:]):			#in some context the file omits the $
			return v + p[len(k) - 1:]
	return p

def makeTempDirPath(p, dirName):
	global sourceTreeAlias
	for k in sourceTreeAlias.iterkeys():
		if p.startswith(k):
			return './temp/' + dirName + '/' + '_' + p[1:]
		if p.startswith(k[1:]):			#in some context the file omits the $
			return './temp/' + dirName + '/' + '_' + p
	return './temp/' + dirName + '/' + '_' + p


class MakeBuildSettings(BuildSettings):
	def writeFlags(self, out):
		out.write('# Compiler Flags\n')
		if self.headerSearchPaths != []:
			out.write('INCLUDE_FLAGS =')
			for h in self.headerSearchPaths:
				nonQuoteIndex = h[0] == '"' and 2 or 1
				p = os.environ.get(h[nonQuoteIndex:])
				if p == None: 
					s = 'Unknown source tree (%s not defined)' % h; 
					raise ValueError, s
				sourceTreeAlias[h] = p
				out.write(' -I%s' % p)
			out.write('\n')
		out.write('INCLUDE_FILE =')
		if self.GCC_PREFIX_HEADER != '':
			out.write(' -include %s' % makePathAbsolute(self.GCC_PREFIX_HEADER))
		out.write('\nCPPFLAGS = %s -O%d\n' % (makePathAbsolute(self.OTHER_CPLUSPLUSFLAGS), self.optimizationLevel))
		out.write('\nWARNING_CFLAGS = %s\n' % makePathAbsolute(self.WARNING_CFLAGS))

class MakeTarget(PBXNativeTarget):
	def writeMakefile(self, out, project):
		global versionString, xcodeFileName, makefileName
		buildName = self.buildSettings.PRODUCT_NAME
		if self.buildSettings.isDebugTarget:
			buildName = buildName + '_d'
		out.write('# product = %s, buildStyle = %s\n' % (buildName, self.buildSettings.buildStyleName))
		out.write('# written by %s version %s, from the XCode project: %s\n' % (sys.argv[0], versionString, xcodeFileName)) 
		out.write('CXX = g++\n')
		self.buildSettings.writeFlags(out)
		out.write('%s_OBJS = ' % buildName.upper())
		objectsToBuild = {}
		sources = self.getSources()
		for f in sources:
			fp = makeTempDirPath(f, buildName + self.buildSettings.buildStyleName)
			ind = fp.rfind('.')
			if ind < 0: raise ValueError, ('Expecting . in filename: %s' %fp)
			oFile = fp[:ind] + '.o'
			objectsToBuild[oFile] = makePathAbsolute(f)
			out.write('\\\n\t%s ' % oFile)
			ind = fp.rfind('/')
			if ind >= 0:
				verifyDirs(fp[:ind + 1])
		out.write('\nclean: \n')
		for o, c in objectsToBuild.iteritems():
			out.write('\trm -f %s\n' % o)
		out.write('\n# now write rules for each file (crude, but it is autogenerated so why not?)\n')
		out.write('%s : %s\n' % (buildName, makefileName))
		for o, c in objectsToBuild.iteritems():
			out.write('\t$(CXX) $(INCLUDE_FILE) $(INCLUDE_FLAGS) $(CPPFLAGS) $(WARNING_CFLAGS) -c %s -o %s \n' % (c, o))
		out.write('\t$(CXX) -o %s $(%s_OBJS) -lm -lstdc++' % (buildName, buildName.upper()))

def getCompilerPlatformSettings(targettedOS):
	targettedOS = targettedOS.upper()
	if targettedOS == 'LINUX':
		return (['-DLINUX_PHOREST'],
				{'-Wno-long-double' : '',
				'-Wmost' : '',
				'-Wno-four-char-constants' : ''})
	return ([], {})
if __name__ == '__main__':
	if len(sys.argv) < 2:	print 'Usage: %s xcode_project {Makefile_name}' % sys.argv[0]; sys.exit(1)
	xcodeFileName = sys.argv[1]
	addCompFlags, compilerTrans = getCompilerPlatformSettings(len(sys.argv) > 2 and sys.argv[2] or 'LINUX')
	typeToTypeMap = {PBXNativeTarget : MakeTarget, BuildSettings : MakeBuildSettings}
	project, files = readXCodeProject(xcodeFileName, addCompFlags, compilerTrans, typeToTypeMap)
	if len(project.targets) == 0: sys.exit('No targets found')
	for t in project.targets:
		makefileName = 'make_' + t.buildSettings.PRODUCT_NAME + '_' + t.buildSettings.buildStyleName
		out = open(makefileName, 'w')
		t.writeMakefile(out, project)
			
