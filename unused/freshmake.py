#!/usr/bin/python
'''Script called by cron jobs to do nightly clean builds (no attempt to avoid unnecessary recompilation has been made).
The script:
	1	updates from cvs, 
	2	generates all autogenerated files (source and makefiles),
	3	performs a clean make (on mac and linux).
Soon we will add 'Runs tests' to this list.
Note that the gui code is only rebuilt if 'gui' is passed as the first (and only) argument
'''

import os,sys
from os.path import join as topath
if os.environ.get('PHYCAS_ROOT') is not None:
	sys.path.append(os.path.join(os.environ['PHYCAS_ROOT'], 'python'))
from phycas_util import quoteDirIfNeeded
usingSubProcess = False
if int(sys.version[0]) > 2 or (int(sys.version[0]) == 2 and int(sys.version[2]) >= 4):
	from subprocess import *
	usingSubProcess = True

	################################################################################
	# 	Some global variable and constants that (currently) are simply hard-coded
	# 	Note all directories are relative to PHYCAS_ROOT (the phycasdev directory)
	#	See BuildToolSettings initializations below for more hard-coded info.
	################################################################################
  # Paths
schemaDir = topath('command_archive', 'xml')
pathToGUIHandlerDir = topath('gui', 'phycasGUI', 'swixml', 'handler')
  # Fail hints (messages to display if a command fails, that might help us figure out what went wrong
scompFail = '''Make sure you 
	1	you have xmlbeans
	2	XMLBEANS_HOME is set
	3	XMLBEANS_HOME/bin is in your path'''
cvsFail = '''Generic hints.  Check:
	1	you have passwordless authentication to machines that mount the csit fs
	2	CVSROOT is set to user_id@cvs.csit.fsu.edu:/usr/local/cvs
	3	CVS_RSH is set to the path to ssh'''
version = '1.0'
redirectDefault = '' # by default all invoked command's stdout goes to stdout
toolsEnvironSetting = 'PHYCAS_TOOLS'
if sys.platform.upper().startswith('DARWIN'):
	platform = 'mac'
else :
	if sys.platform.upper().startswith('WIN'):
		platform = 'windows'
		redirectDefault = ''
	else:
		platform = 'linux'
def executeCmd(c, failHint = '', redirectTo = ''):
	'''Prints the command to be issued to sys.stdout, and exits if the command fails.'''
	global redirectDefault
	if redirectTo == '': 
		redirectTo = redirectDefault
	print 'From ', os.path.abspath('.')
	if (not usingSubProcess) and redirectTo != '':
		c.extend(['>', redirectTo])
	shelcmd = ' '.join([quoteDirIfNeeded(w) for w in c])
	print '  ', shelcmd , ' ...',
	sys.stdout.flush()
	if not usingSubProcess:
		if os.system(shelcmd): 
			sys.exit('\n"%s" Failed.  %s' % (c, failHint)) ; 
	else:
		p = Popen(shelcmd, shell=True, stderr=PIPE)
		child_stderr = p.stderr
		p.wait()
		if p.returncode != 0:
			sys.exit(''.join([l for l in child_stderr]) + '\n' + shelcmd + ' failed with return code of ' + str(p.returncode))
	print 'Completed.'

def executeCmdFromDir(c, failHint = '', fromDir = '.', redirectTo = ''):
	'''Changes to the fromDir directory and calls executeCmd'''
	origDir = os.path.abspath('.')
	os.chdir(fromDir)
	if len(redirectTo) > 0:
		redirectTo = topath(fromDir, redirectTo)
	executeCmd(c, failHint, redirectTo)
	os.chdir(origDir)

def autogenerateCode(phycasRoot = '.', transformArg = ''):
	'''takes a string which should be 'CPP' 'GUI' or '' ('' builds code for both cpp and gui)'''
	if len(transformArg) > 0 and transformArg.upper() != 'CPP' and transformArg.upper() != 'GUI':
		raise ValueError, transformArg
		# we need to clear the handler directory, because if a command is deprecated it's remnants will 
		#	remain (the transform_cmd_xml.py script doesn't clear any directory)
		#	This is more of a problem for JAVA because netbeans and ant will try to compile everything in the directory.
	print 'generation of gui code disabled for speed'
	#oldHandlerCodeFiles = os.listdir(pathToGUIHandlerDir)
	#for f in oldHandlerCodeFiles:
	#	if f.endswith('.java'):
	#		os.remove(topath(pathToGUIHandlerDir, f))
	#executeCmdFromDir(['python', 'transform_cmd_xml.py', transformArg.upper()], '', phycasRoot)
	executeCmdFromDir(['python', 'transform_cmd_xml.py', 'CPP'], '', phycasRoot)

def refreshGUIHelp(phycasRoot = '.'):
	''' Takes path to phycasRoot.  Regenerates help index and associated files.'''
	executeCmdFromDir(['jhindexer', 'master'], 'Make sure JAVAHELP_HOME is in your classpath', topath(phycasRoot, 'gui', 'help'))

def generateXMLBeansCode(phycasRoot = '.'):
	''' Calls scomp with the command_language and command_state schemas'''
	executeCmd(['scomp', '-out', topath(phycasRoot, 'gui', 'commandLanguage.jar'), topath(phycasRoot, schemaDir, 'phycas_command_language.xsd')], scompFail)
	executeCmd(['scomp', '-out', topath(phycasRoot, 'gui', 'commandState.jar'), topath(phycasRoot, schemaDir, 'command_state.xsd')], scompFail)

def compileGUI(phycasRoot = '.'):
	'''Calls ant to build buildGui.xml and buildExec.xml'''
	executeCmd(['ant', '-f', topath(phycasRoot, 'build', 'buildGui.xml')])
	executeCmd(['ant', '-f', topath(phycasRoot, 'build', 'buildExec.xml')])

def compilePhycasServer(phycasRoot, buildTool):
	'''Takes phycasRoot and buildTool.  calls buildTool build().'''
	origDir = os.path.abspath('.')
	os.chdir(topath(phycasRoot, buildTool.projectRoot))
	buildTool.build()
	os.chdir(origDir)
	import shutil
	ep = topath(buildTool.projectRoot, buildTool.exePath)
	dest = topath('executor', 'PhycasSocket.exe')
	print 'Copying', ep, 'to', dest
	shutil.copy(ep, dest)

def refreshDocumentation(phycasRoot):
	origDir = os.path.abspath('.')
	os.chdir(topath(phycasRoot, 'doc'))
	doxyfiles = ['executor_doxyfile', 'gui_doxyfile', 'phycas_doxyfile', 'Doxyfile' ]
	for df in doxyfiles:
		executeCmd(['doxygen', df])
	os.chdir(origDir)

def testPhycasServer(phycasRoot, exePaths):
	'''Takes path to phycasRoot and path from phycasRoot to executable. Calls run_whole_program_tests.py on the specified executable'''
	for p in exePaths:
		executeCmdFromDir(['python', 'run_whole_program_tests.py', topath('..', p), 'in', 'phycasOut', 'USEFTS'], '', topath(phycasRoot, 'testing'))

def generateIDEProjectFromXCode(phycasRoot, buildTool, xcodeProj):
	buildTool.generateFromXCode(phycasRoot, xcodeProj)

def doCVSUpdate(phycasRoot):
	executeCmdFromDir(['cvs', 'update', '-d'], cvsFail, phycasRoot)

def runPhycasBuildHelper(options, phycasRoot, buildTool):
	if os.path.abspath(phycasRoot) != os.path.abspath('.'):
		print 'changing working directory to ', phycasRoot
		os.chdir(phycasRoot)
	if options.cvs:
		doCVSUpdate(phycasRoot)
	if options.code or options.cpp or options.gui:
		if options.code:
			transformArg = ''
		else:
			transformArg = options.cpp and 'CPP' or 'GUI'
		autogenerateCode(phycasRoot, transformArg)
	if options.ide:
		generateIDEProjectFromXCode(phycasRoot, buildTool, topath(phycasRoot, xcodeSettings.projectRoot, xcodeSettings.internalProjFile))
	if options.gui:
		generateXMLBeansCode(phycasRoot)
		refreshGUIHelp(phycasRoot)
	if options.gui or options.guibuild:
		compileGUI(phycasRoot)
	if options.cpp or options.cppbuild:
		compilePhycasServer(phycasRoot, buildTool)
	if options.test:
		testPhycasServer(phycasRoot, buildTool.getExePathsFromPhycasRoot())
	if options.doc:
		refreshDocumentation(phycasRoot)

def partition(pred, iterable):
	'''returns a pair of lists: ([iterable items for which pred is True], [iterable items for which pred is False])'''
	tList = []
	fList = []
	for i in iterable:
		if pred(i):
			tList.append(i)
		else:
			fList.append(i)
	return tList, fList

def moveOptionsToObject(option_dict, obj):
	for k, v in option_dict.iteritems():
		obj.__dict__[k.lstrip('-')] = v[0]
def printHelpMessage(outStream, name , buildTool = None, phycRoot = None):
	global optDict
	printVersionInfo(outStream)
	print >>outStream, 'A python script to automate some of the tasks required when building phycas.'
	print >>outStream, 'The following options are recognized:'
	for k, v in optDict.iteritems():
		opt = (k[-1] == ':' or k[-1] == '=') and k[:-1] or k
		print >>outStream, '%-12s%s' % (opt, v[1])
	if buildTool != None:
		print >>outStream, 'C++ code will be compiled using', buildTool.toolName, '(override with -t argument or %s environmental setting).' % toolsEnvironSetting
	if phycRoot != None:
		print >>outStream, 'Phycas root directory is ', phycRoot, ' (override with -r argument or PHYCAS_ROOT environmental setting).'
def printVersionInfo(outStream):
	print >>outStream,  sys.argv[0], 'version', version

	################################################################################
	#	Compiler/Platform constants
	#	BuildToolSettings holds hard coded infor all of the supported and experimental 
	#	build tools.
	################################################################################
class BuildToolSettings:
	def __init__(self, projRoot, buildDir, exeName, projPath):
		self.projectRoot = projRoot
		self.buildDir = buildDir
		self.exeName = exeName
		self.exePath = topath(buildDir, exeName)
		self.projectPath = projPath
		self.autoGenProjProduced = ''
		self.toolName = '?'
	def generateFromXCode(self, phycasRoot, xcFile):
		if self.__dict__.has_key('genScript'):
			executeCmdFromDir(['python', topath(phycasRoot, self.genScript), topath(phycasRoot, xcFile)], '', topath(phycasRoot, self.projectRoot, self.autoGenProjProduced))
	def getExePathsFromPhycasRoot(self):	return [topath(self.projectRoot, self.exePath)]
	def getProjPathFromPhycasRoot(self): 	return topath(self.projectRoot, self.projectPath)
	def __str__(self): 						return self.toolName + ' ' + self.getProjPathFromPhycasRoot()
class MakeSettings(BuildToolSettings):
	def __init__(self, projRoot, buildDir, exeName, projPath):
		BuildToolSettings.__init__(self, projRoot, buildDir, exeName, projPath)
		self.genScript = topath('python', 'xcode_to_make.py')
		self.toolName = 'make'
	def build(self):
		for mode in [('Debug', '_d')]: # [('Debug', '_d'), ('Release', '')]:
			for target in ['phycas']: # ['console_phycas', 'phycas']:
				makefilename = 'make_%s_%s' % (target, mode[0])
				maketarget = '%s%s' % (target, mode[1])
				executeCmd(['make', '-f', makefilename, 'clean']),
				executeCmd(['make', '-f', makefilename, maketarget])
class XCodeSettings(BuildToolSettings):
	def __init__(self, projRoot, buildDir, exeName, projPath):
		BuildToolSettings.__init__(self, projRoot, buildDir, exeName, projPath)
		self.internalProjFile = topath(projPath, 'project.pbxproj')
		self.defaultTarget = 'phycas'
		self.defaultBuildStyle = 'Development'
		self.toolName = 'xcodebuild'
	def build(self):
		executeCmd(['xcodebuild', '-project', self.projectPath, '-target', self.defaultTarget, '-buildstyle', self.defaultBuildStyle])

class VCSettings(BuildToolSettings):
	def __init__(self, projRoot, buildDir, exeName, projPath):
		BuildToolSettings.__init__(self, projRoot, buildDir, exeName, projPath)
		self.solutionName = 'VS.sln'
		self.toolName = 'VC'
	def build(self):
		executeCmd(['devenv', '/build', os.path.basename(self.buildDir), '/project "%s"' % self.projectPath,  '"%s"' % self.solutionName])

class JamSettings(BuildToolSettings):
	def __init__(self, projRoot, buildDir, exeName, projPath):
		BuildToolSettings.__init__(self, projRoot, buildDir, exeName, projPath)
		self.genScript		= topath('python', 'xcode_to_bjam.py')
		self.toolName = 'bjam'
	def build(self):
		executeCmd(['bjam'])

class MWerksSettings(BuildToolSettings):
	def __init__(self, projRoot, buildDir, exeName, projPath):
		BuildToolSettings.__init__(self, projRoot, buildDir, exeName, projPath)
		self.genScript		= topath('python', 'xcode_to_mwerks.py')
		self.autoGenProjProduced 	= 'auto_phycas.mcp.xml'
		self.toolName = 'mwerks'
	def build(self):
		print 'no command line build tool for metrowerks.'

supportedTools = ['MAKE', 'XCODE', 'VC', 'VCAUTO', 'JAM', 'MWERKS'] 
recognizedTools = supportedTools + ['ALL']
class AllToolMetaSettings:
	supportedTools = []
	def __init__(self):
		global supportedTools
		self.projectRoot = '.'
	def generateFromXCode(self, phycasRoot, xcFile):
		for b in AllToolMetaSettings.supportedTools:
			b.generateFromXCode(phycasRoot, xcFile)
	def build(self):
		origDir = os.path.abspath('.')
		for b in AllToolMetaSettings.supportedTools:
			os.chdir(topath(origDir, b.projectRoot))
			b.build()
		os.chdir(origDir)
	def getExePathsFromPhycasRoot(self):
		p = []
		for b in AllToolMetaSettings.supportedTools:
			p.extend(b.getExePathsFromPhycasRoot())
		return p
	def getBuildToolNames(self):
		return 'ALL tools(%s)' % ' '.join([b.toolName for b in AllToolMetaSettings.supportedTools])
	toolName = property(getBuildToolNames)
	
makeSettings 	= MakeSettings(		'build', 							'', 									'phycas', 		'make_phycas_Debug')
xcodeSettings 	= XCodeSettings(	topath('build', 'xcode_proj'), 		'build', 								'phycas', 		'Phycas.xcode')
handVCSettings 	= VCSettings(		topath('build', 'VC'), 				topath('phycas', 'SocketDebug'),		'phycas.exe',	topath('phycas', 'phycas.vcproj'))
autoVCSettings 	= VCSettings(		topath('build', 'autoVC', 'phycas'),'', 									'phycas.exe',	'phycas.vcproj')
mwerksSettings	= MWerksSettings(	topath('build', 'autoMWerks'), 		'', 									'phycas', 		'auto_phycas.mcp')
jamSettings		= JamSettings(		'', 								topath('jam_phycas', 'gcc', 'debug'), 	'phycas',		'Jamfile')
autoVCSettings.genScript	= topath('python', 'xcode_to_vc.py')
toolSetPathInfo = 	{
					'MAKE'	: makeSettings,
					'XCODE'	: xcodeSettings, 
					'VC'	: handVCSettings,
					'VCAUTO': autoVCSettings,
					'MWERKS': mwerksSettings, 
					'JAM'	: jamSettings,
					'ALL'	: AllToolMetaSettings()
					}
AllToolMetaSettings.supportedTools = [toolSetPathInfo[i] for i in supportedTools]
toolSetName = os.environ.get(toolsEnvironSetting)
if __name__ == '__main__':
		################################################################################
		#	define phycas_build_helper options
		################################################################################
	optDict = {	'--cvs': 		[	False,
'Perform "cvs update -d" (will be the first action taken).'],
				'--cpp': 		[	False,
'Refresh the C++ portion of the executable (code and build)' ],
				'--gui': 		[	False,
'Refresh the GUI (transform to generate code and compile)'],
				'--guibuild': 	[	False,
'Perform "scomp" and ant builds to remake PhycasGUI'],
				'--ide': 		[	False,
'Create Metrowerks and VC projects from the xcode project'],
				'--cppbuild': 	[	False,
'Build C++ portion of the executable'],
				'--code': 		[	False,
'''Autogenerates code for gui and C++ program from the
              command language xml'''],
				'--test': 		[	False,
'Run the battery of whole program tests in testing/in'],
				'--doc': 		[	False,
'Refresh doxygen-generated documentation'],
				'--all': 		[	False,
'Acts as if every --option (other than --help were specified)'],
				'--nocvs': 		[	False,
'''Acts as if every --option other than --help and
              --cvs were specified'''],
				'--help': 		[	False,
'Display this help message.'],
				'-r:': 			[	False,
'''Specify path to phycas root directory (overrides the
              PHYCAS_ROOT environmental setting, which
              overrides ".")'''],
				'-h': 			[	False,
'Display this help message.'],
				'-t:': 			[	False,
'''One of {%s}. Determines
              which C++ compiler tool set to use''' % '|'.join(recognizedTools)],
				'-v': 			[	False,
'displays version'],
				'-q':			[	False,
'quiet mode']
				}
	longOpts, shortOpts = partition(lambda x: x.startswith('--'), optDict.iterkeys())
	
		################################################################################
		#	parse the command line.  
		#	special treatment for -t (toolset specifier) and --all
		#	make data members of an Options class for readability.
		#	initialize and validate phycasRoot and buildTool
		################################################################################
	import getopt
	class Options: pass
	try:
		optsRead, unparsed = getopt.getopt(sys.argv[1:], ''.join([i[1:] for i in shortOpts]), [i[2:] for i in longOpts])
	except getopt.GetoptError, e:
		sys.exit(e)
	  #	initialize and validate phycasRoot
	if len(unparsed) > 0:
		print >>sys.stderr, 'No arbitrary arguments accepted'
		printHelpMessage(sys.stderr, sys.argv[0])
		sys.exit(1)
	phycasRoot = os.environ.get('PHYCAS_ROOT')
	if phycasRoot == None:
		phycasRoot = '.'
	  #interpret options and deal with all of the short flags
	for op in optsRead:
		opt = op[0]
		for k, v in optDict.iteritems():
			if k == opt or str(k)[:-1] == opt:
				v[0] = True
				break
		if opt == '-t':
			toolSetName = op[1]
		elif opt == '-r':
			phycasRoot = op[1]
	if not os.path.exists(phycasRoot):
		sys.exit('The path %s (the specified PHYCAS_ROOT) does not exist' % phycasRoot)
	   # check for help before '--all' can turn on every setting
	helpNeeded = optDict['--help'][0] or optDict['-h'][0] or len(optsRead) == 0
	if optDict['-v'][0] and not helpNeeded:
		printVersionInfo(sys.stdout)
	if optDict['-q'][0]:
		redirectDefault = platform == 'windows' and '_freshmake_stdout_redirect' or '/dev/null'
		print 'Redirecting command output to ', redirectDefault
	  # deal with "all" option (cache help info first)
	exitNeeded = len(optsRead) == 0
	if optDict['--all'][0] or optDict['--nocvs'][0]:
		nocvs = optDict['--nocvs'][0]
		for k, v in optDict.iteritems():
			v[0] = True
		if nocvs: 
			optDict['--cvs'][0] = False
	  #	make data members of an Options class for readability, and remove keys that we won't be using for the rest of the script.
	options = Options()
	moveOptionsToObject(optDict, options)
	del options.__dict__['help']
	for k in filter(lambda x : str(x)[1] != '-', optDict.iterkeys()): # delete all of the single - options
		del options.__dict__[k.lstrip('-')]
	  #	validate toolSetName (and from that buildTool)
	buildTool = None
	if toolSetName == None:
		if options.cpp or options.cppbuild or options.ide:
			if helpNeeded:	printHelpMessage(sys.stdout, sys.argv[0])
			sys.exit('Build Tool set must be specified by setting environmental variable %s or using the -t option)' % toolsEnvironSetting)
	elif not toolSetName.upper() in recognizedTools:
		if helpNeeded:	printHelpMessage(sys.stdout, sys.argv[0])
		sys.exit('Unknown toolSet, %s, expecting {%s} (specified as environmental setting %s or after the -t option).' % (toolSetName, '|'.join(recognizedTools), toolsEnvironSetting))
	else:
		buildTool = toolSetPathInfo[toolSetName.upper()]
	if helpNeeded:	printHelpMessage(sys.stdout, sys.argv[0], buildTool, phycasRoot)
	if exitNeeded:	sys.exit(0)
	if False: #debugging output
		for k, v in options.__dict__.iteritems():
			print 'options.%s = %s' % (k, v)
		print 'buildTool =', buildTool
		print 'phycasRoot = ', phycasRoot
	runPhycasBuildHelper(options, phycasRoot, buildTool)
