<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:cipres="http://command_language.cipres.org"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:mods="http://www.loc.gov/mods/v3"
    targetNamespace="http://command_language.cipres.org" attributeFormDefault="unqualified" elementFormDefault="qualified">
    <xs:import namespace="http://www.loc.gov/mods/v3" schemaLocation="file:/Users/mholder/Documents/projects/Phycas/phycasdev/command_archive/xml/cipres/mods-3-0.xsd"/>
    <!--xs:import namespace="http://www.loc.gov/mods/v3" schemaLocation="http://www.loc.gov/mods/v3/mods-3-0.xsd"/-->
    <xs:element name="module">
        <xs:annotation>
            <xs:documentation>The root element. The base of a hierarchy commands that can be
                interpreted. Modules will generally correspond to stand alone programs, but could
                also represent subsets of a program's functionality or the union of a multiple
                simple programs (which communicate with each other or are state-less, so do not need
                to communicate). Throughout this schema the phrase application object will be used
                to refer to either a module, command or command parameter. Currently groupings
                (command groups and command parameter groups are not first order objects, but are
                merely used to provide hints about presentation).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="description" type="cipres:description"/>
                <xs:element name="conditional" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="shared_settings" type="cipres:shared_settings" minOccurs="0"/>
                <xs:element ref="cipres:command_group" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <!--
    
  BEGIN definition of elements relating to run-time checking of validity   
    
    -->
    <xs:complexType name="test_description">
        <xs:sequence>
            <xs:element name="failure_message" type="xs:string" minOccurs="0"/>
            <xs:element name="annotation" type="xs:string" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="base_test">
        <xs:sequence>
            <xs:element name="description" type="cipres:test_description" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="any_value_operand">
        <xs:choice>
            <xs:element name="state" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Poorly worked out, we need some way refer to the state of
                        CIPRes and the module object (e.g. Paup)</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="label" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Used to to an element in this modules command language (e.g. a
                        command or command param)</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="callback" type="cipres:widget_callback"/>
            <xs:element name="logical" type="cipres:logical_test"/>
            <xs:element name="comparison" type="cipres:comparison_test"/>
            <xs:element name="const" type="xs:string"/>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="boolean_operand">
        <xs:choice>
            <xs:element name="state" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Poorly worked out, we need some way refer to the state of
                        CIPRes and the module object (e.g. Paup)</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="label" type="xs:string"/>
            <xs:element name="callback" type="cipres:widget_callback"/>
            <xs:element name="logical" type="cipres:logical_test"/>
            <xs:element name="comparison" type="cipres:comparison_test"/>
            <xs:element name="bool_cast" type="cipres:bool_cast_test"/>
            <xs:element name="test_ref" type="xs:string"/>
        </xs:choice>
    </xs:complexType>
    <xs:simpleType name="logical_operator">
        <xs:annotation>
            <xs:documentation>enumeration of the types of logical operations that are supported for
                the left and right operands</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="and"/>
            <xs:enumeration value="xor"/>
            <xs:enumeration value="or"/>
            <xs:enumeration value="not_and"/>
            <xs:enumeration value="not_xor"/>
            <xs:enumeration value="not_or"/>
            <xs:enumeration value="if_left_right">
                <xs:annotation>
                    <xs:documentation>shorthand for ((not left) or right)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="comparison_operator">
        <xs:annotation>
            <xs:documentation>enumeration for comparison of values</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="greater_than"/>
            <xs:enumeration value="less_than"/>
            <xs:enumeration value="equals"/>
            <xs:enumeration value="not_equal"/>
            <xs:enumeration value="less_or_equal"/>
            <xs:enumeration value="greater_or_equal"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="bool_operator">
        <xs:annotation>
            <xs:documentation>enumeration for boolean casts</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="bool"/>
            <xs:enumeration value="not"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="logical_test">
        <xs:complexContent>
            <xs:extension base="cipres:base_test">
                <xs:sequence>
                    <xs:element name="left_operand" type="cipres:boolean_operand"/>
                    <xs:element name="right_operand" type="cipres:boolean_operand"/>
                </xs:sequence>
                <xs:attribute name="operator" type="cipres:logical_operator" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="comparison_test">
        <xs:complexContent>
            <xs:extension base="cipres:base_test">
                <xs:sequence>
                    <xs:element name="left_operand" type="cipres:any_value_operand"/>
                    <xs:element name="right_operand" type="cipres:any_value_operand"/>
                </xs:sequence>
                <xs:attribute name="operator" type="cipres:comparison_operator" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="bool_cast_test">
        <xs:complexContent>
            <xs:extension base="cipres:base_test">
                <xs:sequence>
                    <xs:element name="operand" type="cipres:boolean_operand"/>
                </xs:sequence>
                <xs:attribute name="operator" type="cipres:bool_operator" default="bool"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="conditional">
        <xs:annotation>
            <xs:documentation>The evaluation of boolean test that is performed at run-time. These
                tests can be used to validate user-input or determine command or command parameter availability</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="logical" type="cipres:logical_test"/>
            <xs:element name="comparison" type="cipres:comparison_test"/>
            <xs:element name="bool_cast" type="cipres:bool_cast_test"/>
            <xs:element name="test_ref" type="xs:string"/>
        </xs:choice>
        <xs:attribute name="implemented_at">
            <xs:annotation>
                <xs:documentation>specifies whether the test should be performed by just the
                    user-interface or by the computational backend. Omitting the attribute means
                    that both should implement the test</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="widget"/>
                    <xs:enumeration value="ui"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="name" use="optional"/>
    </xs:complexType>
    <!--     

  END definition of elements relating to run-time checking of validity

    -->
    <!--
    
  BEGIN definition of command parameter elements     
    
     -->
    <xs:element name="cmd_param_group">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation>Related set of commands (e.g. each cmd_param_group could
                    correspond to a panel in a wizard or a portion of a dialog box).</xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="modify_precond" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>Describes a constraint to be met before the command
                                parameter should be displayed as active</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element ref="cipres:cmd_param_group"/>
                    <xs:element name="cmd_param" type="cipres:cmd_param"/>
                    <xs:element name="shared_param" type="cipres:shared_cmd_param_ref"/>
                </xs:choice>
            </xs:sequence>
            <xs:attributeGroup ref="cipres:user_filter_attributes"/>
            <xs:attribute name="ui_label" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>User-readable word (or short phrase) describing the group -
                        used as the label for a box around the gui elements in a single dialog box
                        or as the panel name in a wizard.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="base_cmd_param">
        <xs:annotation>
            <xs:documentation>elements needed by cmd_params of all types</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="description" type="cipres:description"/>
            <xs:element name="modify_precond" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Describes a constraint to be met before the command parameter
                        should be displayed as active</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="execute_precond" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Describes a constraint that must be met before the containing
                        command can be performed (if one of the conditions fails, then the OK button
                        to launch a command will be greyed out).</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attributeGroup ref="cipres:user_filter_attributes"/>
        <xs:attribute name="gui_order" type="xs:integer" use="required"/>
        <xs:attribute name="persistent" type="xs:boolean"/>
        <!--xs:attribute name="placement" type="xs:integer" use="optional"/ had been used for relative order of unnamed command parameters-->
    </xs:complexType>
    <xs:complexType name="shared_cmd_param_ref">
        <xs:annotation>
            <xs:documentation>Reference to a shared command parameter, that may add context specific documentation or tests.</xs:documentation>
        </xs:annotation>
             <xs:complexContent>
            <xs:extension base="cipres:base_cmd_param">
           <xs:attribute name="param_ref" type="xs:string"></xs:attribute></xs:extension></xs:complexContent>
    </xs:complexType>
    <xs:group name="cmd_param_types">
        <xs:choice>
            <xs:element name="bool_type_info" type="cipres:bool_type_info"/>
            <xs:element name="char_set_type_info" type="cipres:set_type_info"/>
            <xs:element name="choice_type_info" type="cipres:choice_type_info"/>
            <xs:element name="double_type_info" type="cipres:double_type_info"/>
            <!--xs:element name="infile_type_info" type="phyc:string_type_info"/-->
            <xs:element name="integer_type_info" type="cipres:integer_type_info"/>
            <!--xs:element name="name_type_info" type="phyc:restricted_string_type_info"/>
                        <xs:element name="outfile_type_info" type="phyc:outfile_type_info"/>
                        <xs:element name="output_type_info" type="phyc:output_type_info"/>
                        <xs:element name="restricted_string_type_info" type="phyc:restricted_string_type_info"/>
                        <xs:element name="string_type_info" type="phyc:string_type_info"/-->
            <xs:element name="tax_set_type_info" type="cipres:set_type_info"/>
            <xs:element name="tree_set_type_info" type="cipres:set_type_info"/>
            <xs:element name="mixed_type_info" type="cipres:mixed_type_info"/>
            <!--xs:element name="distribution_type_info" type="phyc:distribution_type_info"/-->
        </xs:choice>
    </xs:group>
    <xs:complexType name="cmd_param">
        <xs:annotation>
            <xs:documentation>A setting determined by the user (previously called cmd_option, but
                not always optional)</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="cipres:base_cmd_param">
                <xs:sequence>
                    <xs:annotation>
                        <xs:documentation>Currently the *_type_info element indicates what type the
                            parameter represents and encapsulates the elements needed to provide
                            type-specific information. This has the advantage of making the xml
                            description of commands more modular (by lessening dependencies such as
                            "if the cmd_param/param_type attribute is set to boolean then the
                            cmd_param/default must be true or false.") The disadvantage is that the
                            type of the parameter is fundamental infromation that should be in an
                            attribute. TODO: we should discuss this structure. Perhaps an acceptable
                            solution is to have duplication of information: both the *_type_info
                            element and a param_type attribute and rely upon the xml author (or xml
                            authoring tool) to keep verify that the two settings are synchronized.</xs:documentation>
                    </xs:annotation>
                    <!--xs:element name="phycas_impl" type="phyc:man_var_parent" minOccurs="0"/-->
                    <xs:group ref="cipres:cmd_param_types"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:simpleType name="manipulation_operator">
        <xs:annotation>
            <xs:documentation>enumeration of the types of operations used in simple transformations</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="add"/>
            <xs:enumeration value="subtract"/>
            <xs:enumeration value="multipl"/>
            <xs:enumeration value="divide"/>
            <xs:enumeration value="exponentiate"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="value_transformation">
        <xs:complexContent>
            <xs:extension base="cipres:base_test">
                <xs:sequence>
                    <xs:element name="left_operand" type="cipres:boolean_operand"/>
                    <xs:element name="right_operand" type="cipres:boolean_operand"/>
                </xs:sequence>
                <xs:attribute name="operator" type="cipres:manipulation_operator"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:group name="single_element_group">
        <xs:choice>
            <xs:element name="transform_of" type="cipres:value_transformation"/>
            <xs:element name="state" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Poorly worked out, we need some way refer to the state of
                        CIPRes and the module object (e.g. Paup)</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="label" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Used to to an element in this modules command language (e.g. a
                        command or command param)</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="callback" type="cipres:widget_callback"/>
            <xs:element name="const" minOccurs="0">
                <xs:simpleType>
                    <xs:restriction base="xs:string"/>
                </xs:simpleType>
            </xs:element>
        </xs:choice>
    </xs:group>
    <xs:complexType name="primitive_value">
        <xs:sequence>
            <xs:group ref="cipres:single_element_group" minOccurs="0"/>
            <xs:element name="or" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                    <xs:sequence>
                        <xs:choice>
                            <xs:group ref="cipres:single_element_group"/>
                        </xs:choice>
                        <xs:element name="if" type="cipres:conditional" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="description" type="cipres:description" minOccurs="0"/>
        </xs:sequence>
        <xs:attributeGroup ref="cipres:user_filter_attributes"/>
    </xs:complexType>
    <xs:complexType name="string_value_list">
        <xs:choice>
            <xs:element name="callback" type="cipres:widget_callback"/>
            <xs:sequence>
                <xs:element name="element" type="cipres:primitive_value" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>
    <xs:attributeGroup name="def_cmd_param_attributes">
        <xs:annotation>
            <xs:documentation>Placeholder for attributes that are relevant to default values (for
                example a default might represent the "factory" default or a setting from a user's
                "initialization" file, or a previous )</xs:documentation>
        </xs:annotation>
        <xs:attribute name="source" type="xs:string" use="optional"/>
    </xs:attributeGroup>
    <xs:complexType name="def_primitive_element">
        <xs:complexContent>
            <xs:extension base="cipres:primitive_value">
                <xs:attributeGroup ref="cipres:def_cmd_param_attributes"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:element name="alias">
        <xs:annotation>
            <xs:documentation>Used to give a user-friendly name to a value that has special meaning.
                For example PAUP uses 0 in random number seed settings to mean "use the system
                clock" so an alias could specify "system clock" as the label and 0 as the value.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="label" type="xs:string" use="required"/>
            <xs:attribute name="value" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="choice_type_info">
        <xs:annotation>
            <xs:documentation>Holds default string and list of choices (the choices could be
                constant and known, or may be labile, meaning that the choice list must be updated
                using a callback mechanism</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="default" type="cipres:def_primitive_element"/>
            <xs:element name="choices" type="cipres:string_value_list"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="bool_type_info">
        <xs:sequence>
            <xs:element name="default" type="cipres:def_primitive_element"/>
            <xs:element ref="cipres:alias" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="integer_type_info">
        <xs:sequence>
            <xs:element name="default" type="cipres:def_primitive_element"/>
            <xs:element name="minimum" type="cipres:primitive_value" minOccurs="0"/>
            <xs:element name="maximum" type="cipres:primitive_value" minOccurs="0"/>
            <xs:element ref="cipres:alias" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="double_type_info">
        <xs:sequence>
            <xs:element name="default" type="cipres:def_primitive_element"/>
            <xs:element name="minimum" type="cipres:primitive_value" minOccurs="0"/>
            <xs:element name="maximum" type="cipres:primitive_value" minOccurs="0"/>
            <xs:element ref="cipres:alias" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="mixed_type_info">
        <xs:annotation>
            <xs:documentation>type-specific information for a mixed parameter, typically this is a
                parameter that can be specified by string that corresponds to one of a set of
                recognized choices or can be specified as a number (for example in paup LSET PINVAR
                = estimate; and LSET PINVAR = 0.2; are both legal).</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="default" type="cipres:def_primitive_element">
                <xs:annotation>
                    <xs:documentation>0 or 1. This is the index of which of the next two
                        "sub-options" is the default.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="sub_cmd_param" maxOccurs="2" minOccurs="2">
                <xs:complexType>
                    <xs:sequence>
                        <xs:group ref="cipres:cmd_param_types"/>
                        <xs:element name="if" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="set_type_info">
        <xs:annotation>
            <xs:documentation>Fields needed to specify a set (e.g. TaxSet, CharSet, TreeSet). TODO:
                much abstraction is needed here, currently we just have place holders for
                communicating with Phycas to get information about the maximum index, index labels,
                and currently defined sets</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="default" type="cipres:def_primitive_element"/>
        </xs:sequence>
        <xs:attribute name="require_active" type="xs:boolean" default="false"/>
        <xs:attribute name="check_indices" type="xs:boolean" default="true"/>
        <xs:attribute name="size" type="xs:string" default="&gt;0"/>
    </xs:complexType>
    <!--     
    
  END definition of command parameter elements
    
    -->
    <!-- 
    
  BEGIN definition of command  elements      
    
     -->
    <xs:element name="command_group">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation>Related set of commands (e.g. each command_group could correspond
                    to menu or sub-menu in a simple GUI).</xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xs:element name="command" type="cipres:command" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attributeGroup ref="cipres:user_filter_attributes"/>
            <xs:attribute name="ui_label" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>User-readable word (or short phrase) describing the group -
                        used as the name of menu (or sub-menu)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="shared_settings">
        <xs:annotation>
            <xs:documentation>Wrapper for the groups of "global" scope user settings</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="setting_group" maxOccurs="unbounded">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="cmd_param" type="cipres:cmd_param" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="name" type="xs:string" use="required"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="base_command">
        <xs:annotation>
            <xs:documentation>Fields that all commands need (regardless of whether or not they take
                additional parameters)</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <!--xs:element name="availability" type="phyc:test_wrapper" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Specifies a run-time test that must evaluate to True for the
                        command to be available</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="requirement" type="phyc:test_wrapper" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Specifies a run-time test of the command's parameters that
                        must evalate to True for the command to be callable (used to describe tests
                        that are difficult to express in terms of the individual command parameter
                        validation fields - minimum, maximum, etc.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="format" type="phyc:command_format"/-->
            <xs:element name="description" type="cipres:description"/>
            <xs:element name="modify_precond" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Describes a constraint to be met before the command should be
                        displayed as active</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="execute_precond" type="cipres:conditional" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Describes a constraint that must be met before the command can
                        be performed (if one of the conditions fails, then the OK button to launch a
                        command will be greyed out).</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="impl" type="cipres:command_implementation" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Contains information about the details implementation - used
                        to create setup function that instantiates the NCL parser for the text
                        command and the settings structure used internally in phycas to hold the
                        user's options</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required"/>
        <!--xs:attribute name="compilation_target" type="phyc:comp_target" use="required"/-->
        <xs:attribute name="order" type="xs:integer" use="required"/>
        <xs:attribute name="category" type="cipres:cmd_category" use="required"/>
        <xs:attributeGroup ref="cipres:user_filter_attributes"/>
    </xs:complexType>
    <xs:complexType name="command">
        <xs:annotation>
            <xs:documentation>Command used to perform an analysis in the program (similar to a
                parameter with a paragraph in Pise)</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="cipres:base_command">
                <xs:sequence>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="cipres:cmd_param_group"/>
                        <xs:element name="cmd_param" type="cipres:cmd_param"/>
                        <xs:element name="shared_param" type="cipres:shared_cmd_param_ref"/>
                    </xs:choice>
                </xs:sequence>
            </xs:extension>
            <!--xs:sequence>
                    
                </xs:sequence-->
        </xs:complexContent>
    </xs:complexType>
    <xs:simpleType name="cmd_category">
        <xs:annotation>
            <xs:documentation>Categorization of commands base on their behavior.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="getter">
                <xs:annotation>
                    <xs:documentation>retrieves information about the state of the module (does not
                        modify, ie. read-only or const). e.g. "ShowTree" in PAUP</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="setter">
                <xs:annotation>
                    <xs:documentation>tweaks the internal state of the program, is not expected to
                        result in significant computation, e.g. "Set MaxTrees = 100" in PAUP or
                        "MCMCP in MrBayes" </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="analysis">
                <xs:annotation>
                    <xs:documentation>anything goes, e.g. "MCMC" in MrBayes or "HSearch" in PAUP</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="definition">
                <xs:annotation>
                    <xs:documentation>defines a new named object - Definition command will take a
                        name and single parameter describing the new object (no other parameters),
                        e.g. CharSet, TaxSet</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <!-- END definition of command  elements      
    
    
     -->
    <xs:simpleType name="version">
        <xs:restriction base="xs:string">
            <xs:pattern value="[0-9](\.[0-9]{1,5}(\.[0-9]{1,5}))"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="revision_history">
        <xs:annotation>
            <xs:documentation>Information to users and programmers about how two versions of an
                application object differ. TODO needs to be fleshed out: reasons for changes, how to
                restore old behavior, links, ...</xs:documentation>
        </xs:annotation>
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:element name="diff" type="xs:string"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="description">
        <xs:annotation>
            <xs:documentation>Used to document application objects</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="ui_label" minOccurs="0">
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:maxLength value="40"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="version" type="xs:string" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>TODO should be #.#.# format. Version number of commands should
                        be used to denote changes in behavior</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="user_hint" type="xs:string" minOccurs="0"/>
            <xs:element name="full_doc" type="xs:string" minOccurs="0"/>
            <xs:element name="doc_link" type="xs:anyURI" minOccurs="0"/>
            <xs:element ref="cipres:revision_history" minOccurs="0"/>
            <xs:element name="reference" type="mods:modsType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="widget_callback">
        <xs:choice>
            <xs:group ref="cipres:cpp_callback_group"/>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="command_implementation">
        <xs:annotation>
            <xs:documentation>Info needed to writing the functions needed to create the NCL parser
                object for this command</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="ncl">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="setup" type="cipres:ncl_setup"/>
                        <xs:element name="handler">
                            <xs:complexType>
                                <xs:group ref="cipres:cpp_callback_group"/>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="ncl_setup">
        <xs:annotation>
            <xs:documentation>Information used in writing the settings structure and setup function
                used by NCL to instantiate parser code</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="cipres:cpp_callback_group"/>
            <xs:element name="setup_header" type="xs:string" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>lists application program headers that have to be included to
                        compile the code that instantiates an NCL object to parse the command (the
                        NCL headers implicitly used do not need to be declared</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="settings_header" type="xs:string" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>lists application program headers that have to be included to
                        for an C++ compiler to be able to compile a command's settings structure
                        (the NCL headers implicitly used do not need to be declared</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!--xs:element name="settings_struct_owner" type="xs:string" minOccurs="0"/>
			<xs:element name="settings_struct_name" type="xs:string" minOccurs="0"/-->
        </xs:sequence>
    </xs:complexType>
    <xs:group name="cpp_callback_group">
        <xs:annotation>
            <xs:documentation>Group of elements used needed to write the C++ code for calling a
                function (could be a bare function or a method of a class</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="function" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Name of the function to call</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="receiver" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Contains data needed if the call is a member function. Class
                        name is an attribute, body of the element is a snippet of code (could be
                        just a name of a variable) used to get a pointer to the receiver class</xs:documentation>
                </xs:annotation>
                <xs:complexType mixed="true">
                    <xs:attribute name="class" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>fully namespace qualified class name</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:attributeGroup name="user_filter_attributes">
        <xs:annotation>
            <xs:documentation>Grouping of attributes used to filter commands, parameters (or their
                groups) from an interface. Filters describe tests, for a grouping or application
                object to be available, it's filter and those of each of its parents must be
                satisfied. Thus, if a command_group has a user level set to advanced, then none of
                the commands should be displayed (regardless of their user level)</xs:documentation>
        </xs:annotation>
        <xs:attribute name="user_interface" type="cipres:user_interface_enum" use="optional">
            <xs:annotation>
                <xs:documentation>Describes which form of the exectuable
                    (cipres|console|gui|scripting|all) the command set pertains to. Used to filter
                    the command_sets when generating the UI. Default is "all". is intrepetted as
                    every UI.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="user_level" type="cipres:user_level_enum" use="optional"/>
    </xs:attributeGroup>
    <xs:simpleType name="user_interface_enum">
        <xs:annotation>
            <xs:documentation>Specifier that limits which user-interfaces (cipres, console, gui, or
                scripting) that an application object is accessible to</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="console"/>
            <xs:enumeration value="cipres"/>
            <xs:enumeration value="gui"/>
            <xs:enumeration value="scripting"/>
            <xs:enumeration value="cipres|console"/>
            <xs:enumeration value="cipres|gui"/>
            <xs:enumeration value="cipres|scripting"/>
            <xs:enumeration value="console|gui"/>
            <xs:enumeration value="console|scripting"/>
            <xs:enumeration value="gui|scripting"/>
            <xs:enumeration value="cipres|console|gui"/>
            <xs:enumeration value="cipres|console|scripting"/>
            <xs:enumeration value="cipres|gui|scripting"/>
            <xs:enumeration value="console|gui|scripting"/>
            <xs:enumeration value="all"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="user_level_enum">
        <xs:annotation>
            <xs:documentation>Description of the type of user a application object is accessible to
                ordered from basic to normal to advanced to developer. Used to filter commands or
                params from the full set </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="basic"/>
            <xs:enumeration value="normal"/>
            <xs:enumeration value="advanced"/>
            <xs:enumeration value="developer"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>
