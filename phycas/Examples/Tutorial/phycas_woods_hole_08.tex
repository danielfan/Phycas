\documentclass{article}

\setcounter{page}{1}
%\setcounter{secnumdepth}{0}
\setlength{\oddsidemargin}{0.in}
\setlength{\evensidemargin}{0.in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0.0in}
\setlength{\headheight}{0.17in}
\setlength{\headsep}{0.35in}
\setlength{\textheight}{8.in}
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
%\input seteps
\usepackage[round]{natbib}
\bibliographystyle{sysbio}

\usepackage{xspace}
\newcommand{\barLone}{\bar{L}_1}
\newcommand{\barLzero}{\bar{L}_0}
\newcommand{\execmd}[1]{\texttt{#1}\\}
\newcommand{\cmdopt}[1]{\texttt{#1}\xspace}
\newcommand{\cmd}[1]{\texttt{#1}\xspace}
\newcommand{\mb}{MrBayes\xspace}
\newcommand{\paup}{PAUP*\xspace}
\newcommand{\phycas}{Phycas\xspace}
\newcommand{\localfile}[1]{\textsf{#1}\xspace}
\newcommand{\QandA}[2]{\textit{#1}\footnote{#2}\xspace}
% use the fancyhdr package to allow both headers and footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{} % clear all headers and footers
\fancyhead[LO,RE]{Phycas demo}
\fancyhead[RO,LE]{2008 Workshop on Molecular Evolution Woods Hole}
\fancyfoot[LO,LE]{{\footnotesize \copyright\ 2008 by Paul O. Lewis, Mark T. Holder, and David Swofford}}
\fancyfoot[CE,CO]{}
\fancyfoot[RO,RE]{\thepage}

\usepackage{url}

\usepackage{hyperref}
\hypersetup{backref,  pdfpagemode=FullScreen,  linkcolor=blue, citecolor=red, colorlinks=true}
\begin{document}
\tableofcontents


\newpage
%###########################################################################################
\section{\phycas Lab}
%###########################################################################################

The goal of this tutorial is to help you become familiar with running \phycas and interpreting its output. 
Don't rush things. 
If you don't finish the lab, you can always download 
\phycas from \url{http://www.phycas.org} when you get home and finish it there.
The manual available at the web site and the web site itself have instructions for 
installing \phycas if you are using your own machine.

Stylistic conventions used in this document:

\begin{tabular}{l}
	Commands understood by the \phycas are in \cmd{this fixed width font} \\
	Questions for you to answer are in {\em italics}. \\
	Important things to note are in {\bf bold face}. \\
	Names of files \localfile{are in  this font}.\\
	Web site URLs look \href{http://www.google.com}{like this} and are clickable links.
\end{tabular}

%-------------------------------------------------------------------------------------------
\subsection{Background}
%-------------------------------------------------------------------------------------------
\phycas is a software package for Bayesian phylogenetic analysis written by Paul Lewis, Mark Holder and David Swofford.
\phycas is a hybrid program: computationally-intensive tasks are implemented in C++, and the high-level
tasks are done in \href{http://www.python.org/}{python}\footnote{The Phycas manual contains instructions for installing python if you are using an operating system
that does not come with python installed.}.

In fact, the python language is the scripting language of \phycas, and the python interpreter is
the front-end for \phycas. 
So when you write a command file in \phycas you are actually writing a python program.
This has advantages because python interpreter is a powerful, robust, and versatile program for interpreting text commands.
However, it also means that \phycas cannot always be forgiving when it comes to the structure of commands and syntax in general.
We have attempted to add as much flexibility as possible, but be aware that {\bf most commands are case-sensitive and you will have to pay attention to the quoting used in commands in this tutorial}.


\subsubsection{The Phycas.app bundle}
In the lab we will be running \phycas as a double-clickable program built around the open-source iTerm terminal application (\href{http://iterm.sourceforge.net/}{iTerm homepage}).
You can run \phycas from any terminal by invoking python and entering the command:
\begin{verbatim}
from phycas import *
\end{verbatim}
You will {\bf not} have to issue this command when using the \phycas application bundle on Mac, but you {\bf will} have to use the command in all of your \phycas scripts.

If you are not using the Phycas.app bundle, you will need to invoke python and enter the \cmd{from phycas import *} command.
In order for this to work, you have to have \phycas installed in a standard location or your shell's environmental variables must be set correctly.
The Windows-installer for \phycas will set up your environment correctly.
If python shows an error when you try the \cmd{from phycas import *}  command given above, then consult the \phycas manual or ask one
of us for help configuring your environment correctly.

\subsubsection{IPython}
In the lab, the machines are configured to run \phycas through \href{http://ipython.scipy.org/moin/}{IPython} rather than Python itself.  
IPython provides a more user-friendly environment for interactive python than the ``raw'' python interpreter.
The main benefits of IPython are:
\begin{itemize}
	\item Tab-completion of variable names (start to type the name and then hit the Tab-key to fill in the rest of the word or see a list of possible matches),
	\item Native support for a few UNIX commands (most notably \cmd{ls} and \cmd{cd})
	\item Support for any UNIX commands if you start the line with ! (an exclamation point). For example \cmd{!cat myscript.py | grep mcmc} would behave just like the UNIX commands \cmd{cat myscript.py | grep mcmc}
\end{itemize}
To indicate to \phycas that you would like to use IPython, then open the \localfile{$\sim$/.phycas/active\_phycas\_env.sh} 
in a text editor, and change the last line to read:
\begin{verbatim}
export USES_I_PYTHON=1
\end{verbatim}
 

If you decide that you do not like IPython (or if you are running on a machine that does not have the IPython libraries installed), then you can simply edit the active configuration file of phycas. 
Open 
\localfile{$\sim$/.phycas/active\_phycas\_env.sh} 
in a text editor, and change the last line to read:
\begin{verbatim}
export USES_I_PYTHON=0
\end{verbatim}

If you are unsure whether or not you have correctly enabled (or disabled) the IPython-style of interacting with \phycas, you can tell by looking at the prompt.
The IPython prompt looks like this:
\begin{verbatim}
In [2]: 
\end{verbatim}
with the number in bracket indicating the number of commands executed, while the python prompt looks like this:
\begin{verbatim}
>>>
\end{verbatim}


\subsection{Simplest usage}
Locate the directory of example files labeled \localfile{Tutorial} and move it to a convenient location for you.


You can launch the \phycas application by double-clicking the \phycas icon  (later when you have scripts written, you can launch the \phycas by dragging a python script onto the \phycas application icon).
After the libraries have loaded you will see a prompt.
This is the python interpreter waiting for you to give it a command.
The working directory will be your home directory.

\subsubsection{Changing the working directory}
The first step is to set the working directory of \phycas to the directory in which you want to work.
If you are using the IPython interface, and you would like to  move to a directory called \localfile{Desktop/Tutorial} then issue the command:
\begin{verbatim}
In [2]: cd Desktop/Tutorial
In [3]: pwd
In [4]: ls
\end{verbatim}
to change working directory, then show the path to the current directory, and finally list the directory contents.

If you are using the  python interpreter (instead of the IPython interface), you have to issue the commands:
\begin{verbatim}
>>> from phycas import *
>>> os.chdir("Desktop/Tutorial")
>>> os.path.abspath(".")
>>> os.listdir(".")
\end{verbatim}

\subsubsection{Getting help}
A good first step is to get an idea of what actions you can take. 
Call the \cmd{help} function to see a general message about \phycas, and then
use the \cmd{public} function to see a summary of globally available
variables
\begin{verbatim}
help()
public()
\end{verbatim}

A very long list of variables is probably not too helpful to you.
Fortunately, you can pass one of the listed names as an argument
to the help function to see some information about the variable:
\begin{verbatim}
help(readFile)
help(mcmc)
\end{verbatim}

\subsubsection{Setting up a basic MCMC analysis}
The settings that affect the behavior of an MCMC run are all stored
as attributes of an \phycas object with the name \cmd{mcmc}.
In python, objects are collections of data and actions.
You address the attributes of an object by putting a ``.'' between
the name of the object and the name of the attribute.
And you change the value of an attribute by using the ``='' character
to assign the attribute a new value
Let's see how it works:
\begin{verbatim}
mcmc.current()
file_contents = readFile("green.nex")
mcmc.data_source = file_contents.characters
mcmc.current()
\end{verbatim}
If you look through the tables of input settings before and after
the assignment to the \cmdopt{data\_source} attribute, you should see
that the value goes from \cmd{None} to \cmd{Characters from the file green.nex}

Take time to look over the options available for MCMC to get a feeling for
what \phycas can do.
The \cmd{current} and \cmd{help} function for \phycas commands will 
each show two tables, the first for settings that control the behavior
of the analysis, and the second table listing the options that control
the where the output of the command is placed.

As with other Bayesian phylogenetic software, the MCMC sampler will produce a collection of files storing
trees and parameter values.
Now let's configure the output settings, so that the files generated will have names that 
will remind us of the analysis done:
\begin{verbatim}
mcmc.out.log = "basic.log"
mcmc.out.log.mode = REPLACE
mcmc.out.trees.prefix = "green"
mcmc.out.params.prefix = "green"
\end{verbatim}

Now we will set up the length of the MCMC simulation. 
It is important to realize that a ``cycle'' in \phycas is {\bf not}
equivalent to a ``generation'' in \mb \citet{RonquistH2003}
In \mb each generation represents an iteration of:
\begin{enumerate}
	\item propose a new state,
	\item evaluate the posterior probability density,
	\item accept or reject the proposal
\end{enumerate}
But in \phycas a cycle represents a sweep of proposals over all of the parameters
in model -- including several proposed changes to the topology.
In terms of the number of updates, a cycle in \phycas is more or less equivalent (in terms 
of the number of updates) to 100 generations in \mb\footnote{That statement is true, when you use the default settings. 
The \cmd{mcmc} options with the word \cmd{weight} in their name
you can alter the number of times a particular type of update is performed
in each cycle}:
\begin{verbatim}
mcmc.ncycles = 2000
mcmc.sample_every = 10
\end{verbatim}
{\bf This run will almost certainly not be long enough}.
In the interest of time, we will be running short MCMC simulations in the lab, please do
not interpret the number of cycles used in this tutorial 
as recommendations for the appropriate length of the MCMC runs.
As we have discussed several times in the course MCMC is a beautiful, but
fairly dangerous algorithm and it is important that you make an 
effort to verify that your run is long enough before you publish
results.


Before we launch the analysis, let's check the settings according to the MCMC command
to see if there were any errors in the settings:
\begin{verbatim}
mcmc.current()
\end{verbatim}

If everything looks good we can launch the run by calling the \cmd{mcmc} command
as if it were a python function:
\begin{verbatim}
mcmc()
\end{verbatim}

As in \mb, we can summarize the tree trees produced by the \cmd{mcmc} analysis
using a \cmd{sumt} command.
Unlike \mb, the \cmd{sumt} command is not automatically configured to read the files
that were just created.
Once again, we can use the \cmd{current} function to inspect a command's state.
Let's tell the \cmd{sumt} command to read the trees from the \localfile{green.t} file
that was just created by the MCMC analysis:
\begin{verbatim}
sumt.current()
sumt.trees = "green.t"
sumt.current()
\end{verbatim}

Then we can run the sumt command with the syntax:
\begin{verbatim}
sumt()
\end{verbatim}
\textbf{The \cmd{sumt.burnin} setting in \phycas is specified in terms of the number of trees to skip in the file -- not in terms of the generation number.}
You will see the majority-rule consensus trees and the trees that have the 
highest posterior probability in the \localfile{sumt\_trees.pdf} file.

From within IPython on Mac, the easiest way to open the pdf files is to shell-escape and use the \cmd{open} command:
\begin{verbatim}
!open sumt_trees.pdf
\end{verbatim}


In the case of this simple dataset and this short MCMC, it is entirely possible that all of the 
splits will have estimated posterior probabilities of 1.0.
If that is the case, the \cmd{sumt} command will not produce a pdf file showing 
plots of the posterior probability over different divisions of the MCMC
simulation.
We will see examples of these files later in the lab.

Leave this \phycas session with the command:
\begin{verbatim}
exit()
\end{verbatim}
The commands for replaying this example are shown in the section \hyperref[basicpy]{basic.py} and in the file \localfile{basic.py} in the scripts folder that accompanied the lab.

%\subsubsection{Another way to read in data}
%A slightly longer, but more more explicit way to have written the previous 
%script would have started with the lines:
%\begin{verbatim}
%file_contents = readFile("green.nex")
%mcmc.data_source = file_contents.characters
%\end{verbatim}

%In this form we read in the data before telling the \cmd{mcmc} to use this data.
%So after we read the file, we can inspect the contents:
%\begin{verbatim}
%help(file_contents)
%print file_contents.taxon_labels
%print file_contents.characters
%print file_contents.trees
%\end{verbatim}


\section{A note an scripts used in this tutorial}
The \localfile{scripts} directory has the python
scripts \localfile{IntExtPrior.py}, \localfile{NoPolytomy.py},
\localfile{Polytomy.py}, and \localfile{basic.py}
that have all of the commands needed to run the tutorial.
To use those scripts, you will have to move them
from the \localfile{scripts} directory to the directory
with the data files, or edit the
filenames in the scripts to reflect the relative 
path to the data files.

You may prefer to create your own version of the
files as you read the tutorial.
Making mistakes, and seeing how \phycas reports
errors will probably help you learn much more 
than simply invoking the scripts.

If you do create your own scripts, you will have to remember
to start them with the line:
\begin{verbatim}
from phycas import *
\end{verbatim}

An intermediate between simply executing the provided files
and typing them in your self is to open the scripts that are provided in
a text editor and paste the commands when you are given 
a prompt.
This will save you some typing, but allow you to follow 
along with the tutorial in a step-by-step fashion.

\section{Polytomy priors}

One flavor of Bayesian analysis that is implemented in \phycas, but not available in many other Bayesian phylogenetic programs\footnote{Note that polytomy priors {\em are} implemented in Peter Foster's program, \href{http://bmnh.org/~pf/p4.html}{p4}, which is another C/python hybrid program.} is support for prior distributions that place non-zero probability on trees that are not fully-resolved (also referred to as trees with polytomies or trees with multifurcations).
The details of the algorithm (and justifications for the approach) can be found in \citet{LewisHolderHolsinger2005}.
We will be using the same data set that was used in that paper which is a set of algal sequences published by \citet{ShoupL2003}.

This time we will pay more attention to the model and MCMC settings than we did in the basic example above.
Start \phycas from a clean slate:
\begin{enumerate}
	\item open a new window in the \phycas application
	\item change the working directory to a convenient location for working with the \localfile{ShoupLewis.nex}. Note that you do {\bf not} have to change your working directory to match the location to the input file.
	However, if you do not change your working directory then you will have to make sure that you use a relative or absolute path to all of the files that you refer to instead of just using filenames.
\end{enumerate}

Read the file into memory:
\begin{verbatim}
file_contents = readFile("ShoupLewis.nex")
mcmc.data_source = file_contents.characters
\end{verbatim}
if you print the \cmd{file\_contents.characters} attribute you should see that the matrix has 17 taxa and 3341 characters.

\subsection{Setting up the model of evolution}
Now we will configure the model of character evolution. 
Use the \cmd{model.help()} invocation to see the current settings of the model and the explanations of the
attributes.
Note that the \cmd{model.type} is a string that can be \texttt{"gtr"}, \texttt{"hky"} or \texttt{"jc"} and this controls whether some of the other settings are used (for instance the settings associated with kappa are only used if the model.type is \texttt{"hky"}).

Let's configure \phycas to use the HKY model with $\Gamma$-distributed rate heterogeneity:

\begin{verbatim}
model.type = "hky"
model.num_rates = 4
\end{verbatim}
the \cmd{model.num\_rates} is the number of variable rates that are used to approximate the Gamma distribution. 
If you were to set \cmd{model.num\_rates = 1} then you would be selecting a single-rate model that does not use $\Gamma$-distributed rate heterogeneity at all.
We can set the value of the shape parameter of the Gamma distribution, but this is just the value that the sampler will start at.  
It is more important (in the context of setting up an MCMC run) to set the prior distribution for the  shape parameter of the gamma distribution.
We can do this by choosing from among the continuous probability distributions over non-negative numbers.
An Exponential distribution will be fine for the purpose of the lab (The Gamma and Inverse-Gamma distributions are also possible choices):
\begin{verbatim}
model.gamma_shape_prior = Exponential(2.0)
\end{verbatim}
This has just set the prior to be an exponential distribution with mean of 0.5.
\\{\bf NOTE:}  \phycas parameterizes the exponential distribution with the rate parameter with is the reciprocal of the mean of the distribution!
If you are unsure, you can always ``ask'' a distribution what its mean is:
\begin{verbatim}
model.gamma_shape_prior.getMean()
\end{verbatim}


Kappa ($\kappa$), the transition/transversion rate ratio, is usually much greater than 1, so let's use a fairly vague prior with a mean of 4:
\begin{verbatim}
model.kappa_prior = Exponential(0.25)
\end{verbatim}

The only other parameters in the HKY substitution model are the base frequencies\footnote{
Internally, \phycas uses base frequency parameters that are unnormalized $(0,\infty)$ variables.
The base frequencies are obtained by dividing each of the parameters by the sum of the four.
We place priors on the unnormalized versions, which is why we use a GammaDistribution in this example.
Note that putting Gamma($a,1$) priors on the unnormalized versions of the parameters is 
equivalent to placing a Dirichlet($a,a,a,a$) on the frequencies themselves.
So using 4 Gamma(1.0, 1.0) priors for the base frequency parameters, is equivalent to a Dirichlet(1,1,1,1)
prior on the base frequencies (and is also a uniform prior on the frequencies).
}:
\begin{verbatim}
model.base_freq_param_prior = Gamma(1.0, 1.0)
\end{verbatim}

\subsubsection{The priors on the tree}
The tree and branch lengths are also important parts of our model and they need to have
priors assigned to them.
Currently \phycas only support a uniform priors over all tree topologies (within a
class of trees with the same number of internal nodes); so we do not have to set
a prior on the shapes of different resolved trees.
However we do need to say something about the branch lengths.

We could use an Exponential (or Gamma distribution) for the prior on all of the branch lengths, but then we would have to choose a mean.
Choosing a reasonable prior is important for any parameter in a Bayesian analysis, but 
the branch length prior merits extra care because:
\begin{enumerate}
	\item  estimating branch lengths accurately is often crucial to getting the topology correct,
	\item the prior will be applied to a large number of parameters (because there are so many branches in the tree).
\end{enumerate}
\citet{SuchardWS2001} suggested the use of a hierarchical model in which the branch lengths are distributed as exponential variables with a mean of $\mu$.
We refer to $\mu$ as a ``hyperparameter'', and we have to place a prior distribution (a ``hyperprior'') on {\em it}.
This has the advantage of producing a vague prior distribution on the branch length in which the 
mean of the prior distribution for the branch lengths is allowed to tune-itself to the data at hand.
In \phycas, if you have the \cmd{model.edgelen\_hyperprior} attribute set to a distribution (rather than \texttt{None}), you will be using this hierarchical model suggested by \citet{SuchardWS2001}.
For example:
\begin{verbatim}
model.edgelen_hyperprior = InverseGamma(2.10000, 0.90909)
\end{verbatim}
uses an Inverse Gamma distribution with parameters shape parameter of 2.1 and a scale parameter of 0.90909 for the hyperparameter, $\mu$.
This distribution has mean 1 and variance 10.

\subsubsection{MCMC over fully-resolved trees}
Let's perform an initial run in the ``standard'' mode in which polytomies are not considered.
We tell the \cmd{mcmc} command that we do not want to sample trees with polytomies:
\begin{verbatim}
mcmc.allow_polytomies = False
\end{verbatim}

Because we are going to perform an analysis that uses a pseudorandom number generator, it is a 
good idea to explicitly set the seed so that we can repeat the analysis.
Let's create a random number generator, set its seed, and assign it to the mcmc command, and 
tell the mcmc command to start from a random tree that is generated using the same random
number generator:

\begin{verbatim}
rng = RNG()
rng.setSeed(13957)
mcmc.rng = rng
mcmc.starting_tree_source = randomtree(rng=rng)
\end{verbatim}

Now we can configure the MCMC to run a short simulation:
\begin{verbatim}
mcmc.ncycles = 2000
mcmc.sample_every = 10
\end{verbatim}
 and save files with names that will remind us that they are from the no-polytomies run:
\begin{verbatim}
mcmc.out.trees.prefix = "no_p_trees"
mcmc.out.params.prefix = "no_p_params"
mcmc.out.log.prefix = "no_p_output"
\end{verbatim}

Finally, we call \cmd{mcmc()} which starts the MCMC analysis:
\begin{verbatim}
mcmc()
\end{verbatim}

After it has completed we can summarize the results.
We can control the behavior of the MCMC with:
\begin{verbatim}
sumt.outgroup_taxon = "Oedogonium cardiacum"
sumt.trees = "no_p_trees.t"
sumt.burnin = 101
\end{verbatim}

We can specify the names of the files using the \cmd{sumt.out} attributes:
\begin{verbatim}
sumt.out.log.prefix = "no_p_sumt_output"
sumt.out.trees.prefix = "no_p_sumt_trees"
sumt.out.splits.prefix = "no_p_sumt_splits"
sumt()
\end{verbatim}
Take a look at the summaries (they should be in the files \localfile{no\_p\_sumt\_splits.pdf} and \localfile{no\_p\_sumt\_trees.pdf}) and  the strength of support for the clades.

Note that a couple of the internal branches have very short lengths but 
also display very high posterior probabilities.  
\QandA{Which groupings in the tree do you think will display posterior probabilities
which are very sensitive to the prior over tree topologies?}{In most runs the clade of:\\ ({\em Heterochlamydomonas rugosa} + {\em Heterochlamydomonas inaequalis})\\ 
and the clade with :\\ 
({\em Volvox carteri},
{\em Chlamydomonas reinhardtii},
{\em Tetraspora sp.},
{\em Chlamydomonas baca},
the three {\em Heterochlamydomonas} species,
{\em Carteria radiosa}, and {\em Carteria obtusa }
)\
are the ones to which you should pay extra attention.}

\subsection{Allowing Polytomies}
Let's redo the same analysis but allow for polytomies.

Even if you are writing your own scripts for this tutorial, you probably 
want to just copy the script from the \localfile{NoPolytomy.py} analysis and save
the file as \localfile{Polytomy.py}\footnote{You can also use the \cmd{history} command in IPython to see the previous commands. This can be useful if you are using \phycas interactively and would
like to turn you commands into a script.}.
Then we can just change the lines that differ between the two styles of analysis.

Here are the changes that we need to make to enable sampling over unresolved trees:
\begin{verbatim}
mcmc.allow_polytomies = True
mcmc.polytomy_prior = True
mcmc.topo_prior_C = 2.72
\end{verbatim}
You must make these changes to the script before the line that says \cmd{mcmc()}.
The first line tells the MCMC sampler to consider polytomies and the next  two lines
set up the prior distribution over unresolved trees.

\phycas supports priors on the trees based such that different ``resolution classes'' of trees have a particular prior probability, but the easiest prior to understand (and one that seems to work well in practice) is the ``polytomy'' prior discussed by \citet{LewisHolderHolsinger2005}.
In this prior, you specify the ratio of the prior probability of a tree over the probability of another tree that is identical to it except  that it has one fewer internal branch.
This is the ratio associated with collapsing a branch in the tree (the ratio that favors the 
acceptance of a delete-edge form of the ``bush move'' in \phycas).
Using a value for this prior ratio of $e$ (the base of the natural logarithm) was 
suggested by \citet{LewisHolderHolsinger2005}.
This value has no particular significance or justification in this
context (there is no theory saying that you {\em should} use $e$),
but it is aesthetically pleasing in that a tree with one more
branch has to be more than one log-likelihood unit better in
order to be favored over the tree with a polytomy.
The \cmd{mcmc.topo\_prior\_C} option mentioned above is the prior ratio.


Make sure to rename our output files, so that we do not overwrite the files that we just produced
in the run that did not consider polytomies:
\begin{verbatim}
mcmc.out.trees.prefix = "polytomy_trees"
sumt.trees = "polytomy_trees.t"

mcmc.out.params.prefix = "polytomy_params"
mcmc.out.log.prefix = "polytomy_output"
sumt.out.log.prefix = "polytomy_sumt_output"
sumt.out.trees.prefix = "polytomy_sumt_trees"
sumt.out.splits.prefix = "polytomy_sumt_splits"
\end{verbatim}

Now we have changed the command script to run the file. Save it as \localfile{Polytomy.py} in the same directory as your other files for this tutorial.

\subsection{Executing a script}
How do we tell \phycas execute a script?
There are actually three ways to do this:
\subsubsection{Drag-and-drop}
The easiest way to do this on Mac is to simply drag the \localfile{Polytomy.py} file onto the \phycas icon (in the dock if \phycas is running or on the to the application icon if it is not running).

\subsubsection{Executing a script if you are not using the double-clickable application}
If you are {\bf not} running the double-clickable \phycas, then you can launch a new
Terminal (or Command application on Windows) session and from the shell execute the following commands:
\begin{verbatim}
cd <type the directory with the Polytomy.py script here>
python -i Polytomy.py
\end{verbatim}

\subsubsection{Executing a script from within the same \phycas session}
If you already have a \phycas session underway and do not want to start a
new session, you can execute the command:
\begin{verbatim}
execfile("Polytomy.py")
\end{verbatim}
to execute a python script (in this case  \localfile{Polytomy.py}).


\subsection{Comparing the results}
If all goes well, you should have the files created by the run:
\localfile{polytomy\_params.p}, \localfile{polytomy\_sumt\_splits.pdf}, \localfile{polytomy\_sumt\_trees.pdf}, \localfile{polytomy\_trees.t}, and \localfile{polytomy\_sumt\_trees.tre}.
Look at the \localfile{polytomy\_sumt\_splits.pdf}  for evidence of poor mixing  during the MCMC; 
and compare the majority-rule consensus trees and the maximum a posterior trees shown in  \localfile{polytomy\_trees.pdf} to those found in \localfile{no\_p\_sumt\_trees.pdf}

\QandA{Is the maximum a posteriori tree topology a fully resolved tree?}{No, it has 2 polytomies in place of the grouping mentioned above as being sensitive to the prior.}
\section{Using different priors for internal and terminal edge lengths}
\citet{YangR2005} \citep[and][]{Yang2007} suggested using prior probabilities on the internal edges of the tree that strongly favor short lengths as means of reducing the strength
of support for some groupings in a Bayesian phylogenetic analysis.
In fact, they suggest that the prior for internal branches which prefers shorter branch lengths more
strongly when you have a large number of characters in your data set.
These suggestions are alternatives to the polytomy prior approach, and you can try it out from within 
\phycas\footnote{You can also download a version of \mb that has been modified to perform the analysis from Ziheng's software site: \url{http://abacus.gene.ucl.ac.uk/software.html}}
It will be easiest to copy the \localfile{NoPolytomy.py} script that you created earlier 
and modify it.

In particular we need to tell \phycas that we do not want to use the hierarchical model for
branch lengths.
Then we need to set different prior distributions for the internal and terminal branch lengths.

By calling \cmd{model.help()} and \cmd{mcmc.help()} you should be able find the commands that you will have to type to have a internal branch length prior with a mean of 0.0001 and a terminal edge prior with a mean of 0.1 (you can use Exponential distributions for both, but pass in different rate parameters for the Exponential).

The important settings to verify have been changed are:
\begin{verbatim}
model.edgelen_hyperprior = None
model.internal_edgelen_prior = Exponential(10000.0)
model.external_edgelen_prior = Exponential(10.0)

mcmc.allow_polytomies = False
mcmc.out.trees.prefix = "int_ext_trees"
mcmc.out.params.prefix = "int_ext_params"
mcmc.out.log.prefix = "int_ext_output"
sumt.trees          = "int_ext_trees.t"
sumt.out.log.prefix = "int_ext_sumt_output"
sumt.out.trees.prefix = "int_ext_sumt_trees"
sumt.out.splits.prefix = "int_ext_sumt_splits"
\end{verbatim}

Run the analysis, and see how the clade posterior probabilities compare to the previous analyses.

\QandA{Do the results seem comparable to the other analyses?}{Perhaps for you (since there are pseudorandom numbers involved, results may vary if you have not set the seed), but in my runs under this model the results were quite different.
The support of several clades is reduced, but the majority-rule consensus tree also contains 
branches that are not present in the majority-rule tree from the NoPolytomy tree.
The branch lengths are also quite different (which is not too surprising given the very strong prior 
used).}

Note that \citet{YangR2005} do not give specific recommendations about the exact values of the means of  the priors to use.
They discuss the way the prior mean should change as a function of the number of characters sampled, but
do not advocate specific prior means.
Thus, it is possible that the prior mean of 0.0001 is simply too low (and that higher means would result in significantly improved performance).
For some datasets, the priors that Yang and Rannala suggested do result in a majority-rule consensus tree that is less resolved than the ``normal'' Bayesian analysis (polytomies excluded and vague priors on 
branch lengths).

\section{Conclusions}
That is it for this lab! 

Please feel free to try out other aspects of \phycas, and let us know if there were
parts of the tutorial or the user-interface of \phycas that
you found confusing.

If you are interested in programming in python
feel free to ask us about how you can use
\phycas as a library of phylogenetic functions.




\newpage
\section{Scripts used in the tutorial}
\subsection{basic.py}\label{basicpy}
\begin{verbatim}
#!/usr/bin/env python

from phycas import *

print help()
print public()
print help(readFile)
print help(mcmc)

mcmc.current()
mcmc.data_source = "green.nex"
mcmc.current()

mcmc.out.log = "basic.log"
mcmc.out.log.mode = REPLACE
mcmc.out.trees.prefix = "green"
mcmc.out.params.prefix = "green"

mcmc.ncycles = 2000 
mcmc.sample_every = 10
mcmc.current()

mcmc()

sumt.current()
sumt.trees = "green.t"
sumt.current()

sumt()
\end{verbatim}


\newpage
\subsection{NoPolytomy.py}\label{NoPolytomy}
\begin{verbatim}
#!/usr/bin/env python

from phycas import *

file_contents = readFile("ShoupLewis.nex")
mcmc.data_source = file_contents.characters
model.help()
model.type = "hky"
model.num_rates = 4

model.current()

model.gamma_shape_prior = Exponential(2.0)
model.gamma_shape_prior.getMean()
model.kappa_prior = Exponential(0.25)
model.base_freq_param_prior = Gamma(1.0, 1.0)
model.edgelen_hyperprior = InverseGamma(2.10000, 0.90909)

mcmc.allow_polytomies = False

rng = RNG()
rng.setSeed(13957)
mcmc.rng = rng
mcmc.starting_tree_source = randomtree(rng=rng)

mcmc.ncycles = 2000
mcmc.sample_every = 10

mcmc.out.trees.prefix = "no_p_trees" 
mcmc.out.trees.mode = REPLACE 
mcmc.out.params.prefix = "no_p_params" 
mcmc.out.params.mode = REPLACE 
mcmc.out.log.prefix = "no_p_output" 
mcmc.out.log.mode = REPLACE 
mcmc.current()

mcmc()

sumt.outgroup_taxon = "Oedogonium cardiacum" 
sumt.trees = "no_p_trees.t" 
sumt.burnin = 101 
sumt.out.log.prefix = "no_p_output" 
sumt.out.log.mode = APPEND 
sumt.out.trees.prefix = "no_p_sumt_trees" 
sumt.out.trees.mode = REPLACE 
sumt.out.splits.prefix = "no_p_sumt_splits" 
sumt.out.splits.mode = REPLACE 

sumt()
\end{verbatim}


\newpage
\subsection{Polytomy.py}\label{Polytomy}
\begin{verbatim}
#!/usr/bin/env python

from phycas import *

file_contents = readFile("ShoupLewis.nex")
mcmc.data_source = file_contents.characters
model.help()
model.type = "hky"
model.num_rates = 4

model.current()

model.gamma_shape_prior = Exponential(2.0)
model.gamma_shape_prior.getMean()
model.kappa_prior = Exponential(0.25)
model.base_freq_param_prior = Gamma(1.0, 1.0)
model.edgelen_hyperprior = InverseGamma(2.10000, 0.90909)

mcmc.allow_polytomies = True
mcmc.polytomy_prior = True
import math
mcmc.topo_prior_C = math.exp(1.0)


rng = RNG()
rng.setSeed(13957)
mcmc.rng = rng
mcmc.starting_tree_source = randomtree(rng=rng)

mcmc.ncycles = 2000
mcmc.sample_every = 10

mcmc.out.trees.prefix = "polytomy_trees"
mcmc.out.trees.mode = REPLACE 
mcmc.out.params.prefix = "polytomy_params"
mcmc.out.params.mode = REPLACE 
mcmc.out.log.prefix = "polytomy_output"
mcmc.out.log.mode = REPLACE 
mcmc.current()

mcmc()

sumt.outgroup_taxon = "Oedogonium cardiacum"
sumt.trees = "polytomy_trees.t" 
sumt.burnin = 101 
sumt.out.log.prefix = "polytomy_sumt_output"
sumt.out.log.mode = APPEND 
sumt.out.trees.prefix = "polytomy_sumt_trees"
sumt.out.trees.mode = REPLACE 
sumt.out.splits.prefix = "polytomy_sumt_splits"
sumt.out.splits.mode = REPLACE 

sumt()
\end{verbatim}


\newpage
\subsection{IntExtPrior.py}\label{IntExtPrior}
\begin{verbatim}
#!/usr/bin/env python

from phycas import *

file_contents = readFile("ShoupLewis.nex")
mcmc.data_source = file_contents.characters
model.help()
model.type = "hky"
model.num_rates = 4

model.current()

model.gamma_shape_prior = Exponential(2.0)
model.gamma_shape_prior.getMean()
model.kappa_prior = Exponential(0.25)
model.base_freq_param_prior = Gamma(1.0, 1.0)

model.edgelen_hyperprior = None
model.internal_edgelen_prior = Exponential(10000.0)
model.external_edgelen_prior = Exponential(10.0)


mcmc.allow_polytomies = False

rng = RNG()
rng.setSeed(13957)
mcmc.rng = rng
mcmc.starting_tree_source = randomtree(rng=rng)

mcmc.ncycles = 2000
mcmc.sample_every = 10

mcmc.out.trees.prefix = "int_ext_trees" 
mcmc.out.trees.mode = REPLACE 
mcmc.out.params.prefix = "int_ext_params" 
mcmc.out.params.mode = REPLACE 
mcmc.out.log.prefix = "int_ext_output" 
mcmc.out.log.mode = REPLACE 
mcmc.current()

mcmc()

sumt.outgroup_taxon = "Oedogonium cardiacum" 
sumt.trees = "int_ext_trees.t" 
sumt.burnin = 101 
sumt.out.log.prefix = "int_ext_sumt_output" 
sumt.out.log.mode = APPEND 
sumt.out.trees.prefix = "int_ext_sumt_trees" 
sumt.out.trees.mode = REPLACE 
sumt.out.splits.prefix = "int_ext_sumt_splits" 
sumt.out.splits.mode = REPLACE 

sumt()


\end{verbatim}


\newpage
\bibliography{../../../documentation/users/manual}
\end{document}

\label{executingdatafile}
\execmd{cmdhere}
\localfile{algaemb.nex} 
\cmdopt{tratiopr} 

\QandA{q?}{answer}



\section{Fully exploiting the python interface}
This section is intended to give a feel of the advantages of using
python as a front-end for python.
The primary audience is people who are comfortable dabbling with 
python programming.
Our hope is that \phycas will be useful even if have {\bf no}
desire to program -- so this part of the tutorial is {\bf entirely optional}.
If you are not going to ever
write python code to interact with \phycas, then you
can just quickly skip the section and finish the tutorial here.

Even if you are interested in programming some in python,
it is probably inadvisable to type the following instructions in
by hand.  
The script \localfile{scripts/collapseShort.py} is provided 
to perform the steps described below.

The motivation for this example is the idea (suggested by
several people, but no one in the published literature, as 
far as I know) that a ``quick-and-dirty'' polytomy analysis
could be done by:
\begin{enumerate}
	\item running an MCMC example,
	\item collapsing all internal branches that are under some small (and arbitrary)
	threshold branch length, and
	\item summarizing the results
\end{enumerate}
Obviously this procedure is a bit unsatisfying because the threshold
branch length must be set in some {\em ad hoc} fashion.
Nevertheless, it would be interesting to see how such an analysis performs.

In a ``normal'' program, if you wanted to try out a new methodology
you would have to edit the source code and recompile.
Because of the flexibility of python, however, users can actually
alter the behavior of \phycas in very rich and powerful ways.
If we were to look at the code for the \cmd{sumt} command we would see
that the consensus tree is created by recording trees in a particular
data structure by calling the following method:
\begin{verbatim}
    def recordTreeInMaps(self, tree, split_map, tree_key):
        nd = tree.getFirstPreorder().getNextPreorder()
        treelen = 0.0
        has_edge_lens = tree.hasEdgeLens()
        while nd:
            is_tip_node = nd.isTip() or nd.getParent().isRoot()
            edge_len = has_edge_lens and nd.getEdgeLen() or 1.0
            treelen += edge_len
            self.recordNodeInMaps(nd, split_map, tree_key, is_tip_node, edge_len)
            nd = nd.getNextPreorder()
        return treelen

\end{verbatim}
in a python class called \cmd{TreeSummarizer}.

We do not have time or space to fully explain python, here.
In a nutshell this method is calling another function, \cmd{recordNodeInMaps} for 
every node in the tree.
By adding a test that checks if the internal branches have length greater than 0.005
we can filter the trees included in the consensus tree summary so that short branches
are excluded -- just as if they were collapsed into a polytomy.
We can copy this function, add one line, and change the indentation to yield the 
following function:
\begin{verbatim}
def newRecordTreeInMaps(self, tree, split_map, tree_key):
    nd = tree.getFirstPreorder().getNextPreorder()
    treelen = 0.0
    has_edge_lens = tree.hasEdgeLens()
    while nd:
        is_tip_node = nd.isTip() or nd.getParent().isRoot()
        edge_len = has_edge_lens and nd.getEdgeLen() or 1.0
        if edge_len > 0.05:
                treelen += edge_len
            self.recordNodeInMaps(nd, split_map, tree_key, is_tip_node, edge_len)
        nd = nd.getNextPreorder()
    return treelen
\end{verbatim}
Now we can assign replace the old function with our new one:
\begin{verbatim}
TreeSummarizer.recordTreeInMaps = newRecordTreeInMaps
\end{verbatim}

Now we can summarize the ``NoPolytomy'' results from before and see support has changed.

The full script is called \localfile{collapseShort.py} in the scripts file.
Move it to the directory with the output from \localfile{NoPolytomy.py}






If you {\em are} interested in using python and \phycas more
fully, you may be interested in seeing a full list 
of the functions available (giving you more information
than the \phycas functions \cmd{help} and \cmd{public}
mentioned above).
You can ask python for all of the variables that are in memory using the
\cmd{dir} function:
\begin{verbatim}
dir()
\end{verbatim}
This will return a (long) list of strings that are the names of all of the currently
available names that python knows about.  
You can ignore any name that starts with an underscore.


