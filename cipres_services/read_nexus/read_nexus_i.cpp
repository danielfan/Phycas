// -*- C++ -*-
//
// $Id: read_nexus_i.cpp,v 1.17 2005/10/23 00:06:07 plewis Exp $

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:1030
#define INCLUDE_TO_AVOID_LINK_ERROR
// This file inclusion avoids a bizarre anonymous namespace multiple definition link error that TL is getting on Mac 10.3.9 (gcc 3.3)
#if defined(_MSC_VER)
//tucson2005: #warning not allowed in VC7
#	include "./cipres_nexus_reader.cpp"
#	include "ncl/characters/nxs_characters_block.cpp"
#	include "ncl/command/nxs_command_output.cpp"
#else
#	warning using macro to include cipres_nexus_reader.cpp TEMPORARY HACK!
#	include "./cipres_nexus_reader.cpp"
#	warning using macro to include nxs_charcters_block.cpp TEMPORARY HACK!
#	include "ncl/characters/nxs_characters_block.cpp"
#	warning using macro to include nxs_command_output.cpp TEMPORARY HACK!
#	include "ncl/command/nxs_command_output.cpp"
#endif

#include "phycas/force_include.h"
#include "cipres_services/read_nexus/read_nexus_i.hpp"
#include "cipres_services/read_nexus/cipres_nexus_reader.hpp"
#include "ncl/misc/nxs_file_path.hpp"
#include "phycas/trees/trees_manager.hpp"
#include "phycas/characters/characters_manager.hpp"
#include "phycas/taxa/taxa_manager.hpp"
#include "ncl/nxs_token.hpp"
#include "CipresCommlib/CipresAssert.hpp"
#include <map>
using std::vector;
using std::map;
using std::string;
// TAO_IDL - Generated from
// be/be_visitor_interface/interface_is.cpp:52

// Implementation skeleton constructor
CipresIDL_ReadNexus_i::CipresIDL_ReadNexus_i (const  bool verbose)
	:verboseMode(verbose)
	{
	}

// Implementation skeleton destructor
CipresIDL_ReadNexus_i::~CipresIDL_ReadNexus_i (void)
{
}


CipresIDL_ReadNexus_i::CipresNexusReaderShPtr CipresIDL_ReadNexus_i::newNexusReader (
  	CORBA::Short blocksToRead) const
  	{
  	const int blocksToReadBits = static_cast<int>(blocksToRead);
	return CipresNexusReaderShPtr(new CipresNexusReader(blocksToReadBits));
	}

// called after a file or string is read
::CipresIDL::ReadNexus::NumBlockReadSequence * CipresIDL_ReadNexus_i::postNexusReading(
	CipresNexusReaderShPtr mostRecentNexusReader,
	CORBA::Short blocksToRead)
	{
	const int blocksToReadBits = static_cast<int>(blocksToRead);
	nexusReader = mostRecentNexusReader; //store in a persistent variable after successful read
	::CipresIDL::ReadNexus::NumBlockReadSequence_var t = new ::CipresIDL::ReadNexus::NumBlockReadSequence();
	t->length(3);
	boost::shared_ptr<const PhoTaxaManager> taxaMgr = nexusReader->GetTaxaManager();
	boost::shared_ptr<const PhoTreesManager> treesMgr = nexusReader->GetTreesManager();
	boost::shared_ptr<const PhoCharactersManager> charMgr = nexusReader->GetCharactersManager();
	t[CipresIDL::ReadNexus::NEXUS_TAXA_BLOCK_INDEX] = CORBA::Short((blocksToReadBits & (int) CipresIDL::ReadNexus::NEXUS_TAXA_BLOCK_BIT) && taxaMgr && taxaMgr->GetSize() > 0 ? 1 : 0);
	t[CipresIDL::ReadNexus::NEXUS_TREES_BLOCK_INDEX] = CORBA::Short((blocksToReadBits & (int) CipresIDL::ReadNexus::NEXUS_TREES_BLOCK_BIT) && treesMgr && treesMgr->GetSize() > 0 ? 1 : 0);
	t[CipresIDL::ReadNexus::NEXUS_CHARACTERS_BLOCK_INDEX] = CORBA::Short((blocksToReadBits & (int) CipresIDL::ReadNexus::NEXUS_CHARACTERS_BLOCK_BIT) && charMgr && charMgr->GetSize() > 0 ? charMgr->GetNumMatrices() : 0);
	return t._retn();
	}
	
::CipresIDL::ReadNexus::NumBlockReadSequence * CipresIDL_ReadNexus_i::readNexusFile (
    const char * filePath,
    CORBA::Short blocksToRead
  )	  ACE_THROW_SPEC ((CORBA::SystemException, CipresIDL::NexusException))
	{
	try
		{
		CipresNexusReaderShPtr tempNexusReader = newNexusReader(blocksToRead);
		
		NxsInFilePath infilePath(filePath);
		tempNexusReader->ReadNxsFilePath(infilePath);
		
		return postNexusReading(tempNexusReader, blocksToRead);
		}
	catch (const NxsException & x)
		{
		throw CipresIDL::NexusException(x.msg.c_str(), filePath, x.pos, x.line); 
		}
	catch (const std::bad_alloc &)
		{
		throw CORBA::NO_MEMORY();
		}
	}

::CipresIDL::ReadNexus::NumBlockReadSequence * CipresIDL_ReadNexus_i::readStringAsNexus (
    const char * nexusContent,
    CORBA::Short blocksToRead
  )	  ACE_THROW_SPEC ((CORBA::SystemException, CipresIDL::NexusException))
	{
	try
		{
		CipresNexusReaderShPtr tempNexusReader = newNexusReader(blocksToRead);
		
		const std::string s(nexusContent); //adding a new const char * constructor to NxsToken, would eliminate this copy.
		tempNexusReader->ReadStringAsNexus(s);
		
		return postNexusReading(tempNexusReader, blocksToRead);
		}
	catch (const NxsException & x)
		{
		std::cerr << " NxsException caught"<< std::endl;
		throw CipresIDL::NexusException(x.msg.c_str(), "", x.pos, x.line); 
		}
	catch (const std::bad_alloc &)
		{
		throw CORBA::NO_MEMORY();
		}
	catch (...)
		{
		const char * msg = "uncaught exception in readStringAsNexus";
		std::cerr << msg << std::endl;
		throw CipresIDL::NexusException(msg, "", -1, -1); 
		}
	}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::CipresIDL::DataMatrix * CipresIDL_ReadNexus_i::getCharacters (
    CORBA::Short charactersBlockIndex
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
	{
	if (charactersBlockIndex != 0)
		{
		CIPRES_RELEASE_ASSERT("Multiple characters blocks are currently not supported");
		}
	if (!nexusReader)
		{
		CIPRES_RELEASE_ASSERT("readNexusFile must be called before getCharacters()");
		}
	if (charactersBlockIndex >= 0)
		{
		typedef boost::scoped_ptr<CipresNative::DiscreteMatrix> DiscMatrixScPtr;
		DiscMatrixScPtr discMatrix(createNativeDiscreteMatrix(*nexusReader, (unsigned int) charactersBlockIndex));
		::CipresIDL::DataMatrix * toReturn = discMatrix->_retn();
		return toReturn;
		}
	::CipresIDL::DataMatrix_var cipresMat = new ::CipresIDL::DataMatrix();
	return cipresMat._retn();
	}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::CipresIDL::TaxonInfoSeq * CipresIDL_ReadNexus_i::getTaxa (
    CORBA::Short taxaBlockIndex
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
	{
	::CipresIDL::TaxonInfoSeq_var t = new ::CipresIDL::TaxonInfoSeq();
	if (taxaBlockIndex != 0)
		{
		CIPRES_RELEASE_ASSERT("Multiple taxa blocks are currently not supported");
		}
	if (taxaBlockIndex >= 0)
		{
		boost::shared_ptr<const PhoTaxaManager> taxaMgr = nexusReader->GetTaxaManager();
		//@should get the taxa block # taxaBlockIndex here, now we can only handle one so we ignore the arg.
		const unsigned nTaxa = (taxaMgr ? taxaMgr->GetSize(): 0);
		t->length(nTaxa);
		if (nTaxa > 0)
			{
			const VecString labels = taxaMgr->GetAllLabels();
			unsigned ind = 0;
			for (VecString::const_iterator labIt = labels.begin(); labIt != labels.end(); ++labIt, ++ind)
				t[ind] = CORBA::string_dup(labIt->c_str());
			}
		}
	return t._retn();
	}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

::CipresIDL::TreeSeq * CipresIDL_ReadNexus_i::getTrees (
    CORBA::Short treesBlockIndex
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
	{
	::CipresIDL::TreeSeq_var toReturn = new ::CipresIDL::TreeSeq();
	if (treesBlockIndex != 0)
		{
		CIPRES_RELEASE_ASSERT("Multiple trees blocks are currently not supported");
		}
	if (treesBlockIndex >= 0)
		{
		const VecOfTreeDescriptions & allTrees = nexusReader->GetTrees();
		toReturn->length(allTrees.size());
		unsigned currTreeIndex = 0;
		for (VecOfTreeDescriptions::const_iterator trIt = allTrees.begin(); trIt != allTrees.end(); ++trIt, ++currTreeIndex)
			{
			toReturn[currTreeIndex] = CipresIDL::Tree();
			CipresIDL::Tree & t = toReturn[currTreeIndex];
			string newNewick = incrementTreesTaxaIndices(trIt->newick); //cipres indices start at 1, ncl's start at 0
			newNewick.append(";");
			t.m_newick = CORBA::string_dup(newNewick.c_str());
			t.m_name = CORBA::string_dup(trIt->name.c_str());
			t.m_score.noScore(0.0);
			t.m_leafSet.length(trIt->leafSet.size());
			unsigned ind = 0;
			for (NxsIndexSet::const_iterator leafIt = trIt->leafSet.begin(); leafIt != trIt->leafSet.end(); ++leafIt, ++ind)
				t.m_leafSet[ind] = 1 + *leafIt; //cipres indices start at 1, ncl's start at 0
			//SetCorbaLong::const_iterator indIt = indices.begin();
			//for (UInt k = 0; indIt != indices.end(); ++k, ++indIt)
				//t.m_leafSet[k] = *indIt;
			}
		}
	return toReturn._retn();
	}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

char * CipresIDL_ReadNexus_i::getUIXml (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return  CORBA::string_dup(""); // no configuration
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

CORBA::Boolean CipresIDL_ReadNexus_i::execute (
    const char * command,
    CORBA::String_out display
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
	return true; //no configuration.   Maybe we should return false?
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_is.cpp:57

/*
void CipresIDL_ReadNexus_i::remove (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here
  //mth, need to talk to tl about what to do here.
}

*/
